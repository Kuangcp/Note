---
title: 并发
date: 2019-01-16 00:00:04
tags: 
categories: 
---

**目录 start**
 
1. [并发](#并发)
    1. [同步](#同步)
        1. [锁](#锁)
    1. [异步](#异步)
    1. [线程和进程](#线程和进程)
    1. [协程](#协程)
1. [并发编程](#并发编程)

**目录 end**|_2019-04-19 13:05_| [Kuangcp](https://github.com/Kuangcp/Note) | [yi-yun](https://github.com/yi-yun/Memo)
****************************************
# 并发
> 并发编程的理论基础 无关语言 

## 同步
> [码农翻身:那些烦人的同步和互斥问题](https://mp.weixin.qq.com/s?__biz=MzAxOTc0NzExNg==&mid=2665513371&idx=1&sn=c875f64af83306bffca8dd748f1462ff&chksm=80d679d8b7a1f0ce98a0e3a12409805757cd2e958586c54049121f961cf5b2d236530cd019c7&scene=21#wechat_redirect)

> 这种对`共享变量， 共享内存，共享资源`进行访问的程序片段叫做`临界区`， 代码在进入临界区之前一定要做好同步或者互斥的操作。  
- 例如在Java JDK中， 已经对线程的同步做了封装了， 对于生产者-消费者问题，可以直接使用BlockingQueue
   - 非常简单， 完全不用你去考虑这些 wait ,signal , full, empty

### 锁
> 锁是用来锁临界区资源的 , 而不是锁代码块, 锁函数. 那么在Java中: `synchronized` 锁住的是不同线程对同一个对象的访问 [知乎: 锁代码块和锁方法有啥区别啊？](https://www.zhihu.com/question/21295770)

**********************
## 异步

****************
## 线程和进程

*****************
## 协程

- [知乎:协程的讨论](https://www.zhihu.com/question/20511233)
- [协程以及Python实现](http://www.cnblogs.com/zingp/p/5911537.html)

*********************************

# 并发编程
> 在抽象角度考虑并发

- [并发编程网](http://ifeve.com/)

> [参考: 解道 并发编程](https://www.jdon.com/concurrency.html)

> 在过去的30年里，计算机的性能是在摩尔定律的推动下，从现在开始，这将由Amdahl定律决定。编写代码，有效地利用多个处理器可以是非常具有挑战性的。" -- Doron Rajwan

进行多核多服务器时代，并行并发模式更是对程序员的挑战，现在所谓的Thread Programmer世界上也是为数不多，因为线程表面上好像很容易，但在实际应用中真正应付大负荷运算时，原来的线程设计方案漏洞百出。

并发concurrency属于问题域(problem domain), 并行parallelism属于( solution domain)。
并行和并发的区别在于有无状态，并行计算适合无状态应用，而并发解决的是有状态的高性能； 有状态要着力解决并发计算，无状态要着力并行计算

并发主要是要解决资源争夺，并发一般发生在数据聚合的地方，只要有聚合，就有争夺发生，传统解决争夺的方式采取线程锁机制，这是强行对CPU管理线程人为干预，线程唤醒成本高，新的无锁并发策略来源于Java的NIO或Node.js，通过队列+单线程操作资源的方式巧妙避免了多线程，由于只有一个线程，在多核情况下增加了并行计算的机会。

并发模型分两种，并发基础线程和并发组件模型，并发组件模型让使用者接触不到基础线程概念，是一种简化。作为一个高级集成架构师，应该在程序范式的高级层次定义并发，基于组件级别的并发，并且尽可能地避免涉及线程概念以及线程池等底层概念。

实现并发的途径有两种，基于线程和基于事件 [基于线程与基于事件的并发编程之争](https://www.jdon.com/46921)

