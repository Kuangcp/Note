---
title: 并发
date: 2019-01-16 00:00:04
tags: 
categories: 
---

💠

- 1. [并发](#并发)
    - 1.1. [同步](#同步)
    - 1.2. [异步](#异步)
    - 1.3. [线程和进程](#线程和进程)
    - 1.4. [协程](#协程)
    - 1.5. [锁](#锁)
        - 1.5.1. [死锁](#死锁)
- 2. [并发实践](#并发实践)
    - 2.1. [C100K](#c100k)

💠 2024-05-26 17:41:05
****************************************
# 并发
> 并发编程的理论基础 无关语言 

## 同步
> [码农翻身:那些烦人的同步和互斥问题](https://mp.weixin.qq.com/s?__biz=MzAxOTc0NzExNg==&mid=2665513371&idx=1&sn=c875f64af83306bffca8dd748f1462ff&chksm=80d679d8b7a1f0ce98a0e3a12409805757cd2e958586c54049121f961cf5b2d236530cd019c7&scene=21#wechat_redirect)

> 这种对`共享变量， 共享内存，共享资源`进行访问的程序片段叫做`临界区`， 代码在进入临界区之前一定要做好同步或者互斥的操作。  
- 例如在Java JDK中， 已经对线程的同步做了封装了， 对于生产者-消费者问题，可以直接使用BlockingQueue
   - 非常简单， 完全不用你去考虑这些 wait, signal, full, empty

************************

## 异步
Future
promise async 与 await

************************

## 线程和进程

************************

## 协程

- [知乎:协程的讨论](https://www.zhihu.com/question/20511233)
- [协程以及Python实现](http://www.cnblogs.com/zingp/p/5911537.html)

- [Go 实现](/Go/GoBase.md#协程)
- [Kotlin 实现](https://github.com/Kotlin/kotlinx.coroutines)
- [Python 实现](/Python/PythonConcurrency.md#协程-asyncio)
- [Java 实现](/Java/AdvancedLearning/JavaThread.md#协程)

************************

## 锁
> 锁是用来锁临界区资源的 , 而不是锁代码块, 锁函数. 那么在Java中: `synchronized` 锁住的是不同线程对同一个对象的访问 [知乎: 锁代码块和锁方法有啥区别啊？](https://www.zhihu.com/question/21295770)

### 死锁

1. 什么是死锁 
1. 死锁的四个必要条件
    1. 资源互斥
        - `资源`指线程对已经获取到的资源进行排它性使用，即该资源同时只由一个线程占用。如果此时还有其他线程请求获取该资源，则请求者只能等待，直至占有资源的线程释放该资源。
    1. 不可剥夺
        - `资源`指线程获取到的资源在自己使用完之前不能被其他线程抢占，只有在自己使用完毕后才由自己释放该资源。
    1. 持有资源与请求新资源
        - `线程`指一个线程已经持有了至少一个资源，但又提出了新的资源请求，而新资源已被其他线程占有，所以当前线程会被阻塞，但阻塞的同时并不释放自己已经获取的资源。
    1. 环路等待
        - `线程`指在发生死锁时，必然存在一个线程—资源的环形链，即线程集合{T0,T1, T2, …, Tn}中的T0正在等待一个T1占用的资源，T1正在等待T2占用的资源，……Tn正在等待已被T0占用的资源。


************************

# 并发实践
> 在抽象角度考虑并发

- [并发编程网](http://ifeve.com/)

> [参考: 解道 并发编程](https://www.jdon.com/concurrency.html)

> 在过去的30年里，计算机的性能是在摩尔定律的推动下，从现在开始，这将由Amdahl定律决定。编写代码，有效地利用多个处理器可以是非常具有挑战性的。" -- Doron Rajwan

进行多核多服务器时代，并行并发模式更是对程序员的挑战，现在所谓的Thread Programmer世界上也是为数不多，因为线程表面上好像很容易，但在实际应用中真正应付大负荷运算时，原来的线程设计方案漏洞百出。

并发concurrency属于问题域(problem domain), 并行parallelism属于( solution domain)。
并行和并发的区别在于有无状态，并行计算适合无状态应用，而并发解决的是有状态的高性能； 有状态要着力解决并发计算，无状态要着力并行计算

并发主要是要解决资源争夺，并发一般发生在数据聚合的地方，只要有聚合，就有争夺发生，传统解决争夺的方式采取线程锁机制，这是强行对CPU管理线程人为干预，线程唤醒成本高，新的无锁并发策略来源于Java的NIO或Node.js，通过队列+单线程操作资源的方式巧妙避免了多线程，由于只有一个线程，在多核情况下增加了并行计算的机会。

并发模型分两种，并发基础线程和并发组件模型，并发组件模型让使用者接触不到基础线程概念，是一种简化。作为一个高级集成架构师，应该在程序范式的高级层次定义并发，基于组件级别的并发，并且尽可能地避免涉及线程概念以及线程池等底层概念。

实现并发的途径有两种，基于线程和基于事件 [基于线程与基于事件的并发编程之争](https://www.jdon.com/46921)


## C100K
> [参考: 使用四种框架分别实现百万websocket常连接的服务器](https://www.cnblogs.com/cnsanshao/p/4652305.html)  

