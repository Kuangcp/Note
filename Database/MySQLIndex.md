---
title: MySQL索引
date: 2021-05-27 21:36:58
tags: 
categories: 
---

**目录 start**

1. [索引](#索引)
    1. [为何选择 B+ 树结构](#为何选择-b+-树结构)
    1. [基本SQL用法](#基本sql用法)
1. [索引的类型](#索引的类型)
    1. [普通索引](#普通索引)
    1. [唯一索引](#唯一索引)
    1. [主键索引](#主键索引)
    1. [聚集索引](#聚集索引)
    1. [辅助索引/非聚集索引](#辅助索引非聚集索引)
    1. [Hash 索引](#hash-索引)
    1. [倒排索引](#倒排索引)
1. [需要使用索引的场景](#需要使用索引的场景)
1. [SQL执行时不走索引的场景](#sql执行时不走索引的场景)

**目录 end**|_2021-05-27 21:59_|
****************************************

# 索引
> [Official Doc](https://dev.mysql.com/doc/refman/5.7/en/optimization-indexes.html)  

索引是采用特定的数据结构设计(B+Tree 或者 Hash), 为了对若干列进行快速访问  

> 优点
1. 加快查询速度
1. 如果使用唯一索引，保证数据库表中每条数据的唯一性；
1. 加快表与表之间的连接操作
1. 使用排序和分组检索数据时，可以显著的加快排序和分组的时间

> 缺点
1. 需要额外占用存储空间，如果索引建立太多可能会导致索引空间大于数据空间反而降低性能
1. 当对被索引的数据进行DML(增删改), 需要重建索引, 有一定性能影响

> 注意: [Avoiding Full Table Scans](https://dev.mysql.com/doc/refman/5.7/en/table-scan-avoidance.html)

- 业务上具有唯一特性的字段，即使是多个字段的组合，也必须建成唯一索引
- 对长度大于50的 varchar 字段建立索引时，按需求恰当的使用前缀索引，或使用其他方法(例如增加int类型列col_crc32，然后对col_crc32建立索引)
- 合理创建联合索引(避免冗余)，区分度最高的在`最左边`，单个索引的字段数`不超过5个`
- 单张表的索引数量控制在5个以内，若单张表多个字段在查询需求上都要单独用到索引，需要经过DBA评估。查询性能问题无法解决的，应从产品设计上进行重构
- 使用 explain 判断SQL语句是否合理使用索引，`尽量避免` extra 列出现：using file sort，using temporary

- 通常情况下一个SQL语句只能在表上命中一个索引，但还有 索引合并 的情况 [参考: MySQL索引合并的使用与原理](https://blog.csdn.net/gentlezuo/article/details/107677543)  
    - intersect， union， sort-union

## 为何选择 B+ 树结构
> [参考:【原创】为什么Mongodb索引用B树，而Mysql用B+树?](https://www.cnblogs.com/rjzheng/p/12316685.html)  `MongoDB PostgreSQL 都是使用B-Tree`
> [从 MongoDB 及 Mysql 谈B/B+树](https://blog.csdn.net/wwh578867817/article/details/50493940)  
> [分布式数据库千亿级超大表性能优化实践](http://www.itpub.net/2020/02/28/5356/)  

MySQL磁盘块是固定大小，中间节点上存放数据就会导致中间节点上存放指针数据的空间变小，也就意味着引用的子节点更少，树的高度更高（增加了IO次数），极端情况下退化为线性表。

- 叶子节点上存放的数据：
    - 如果是聚簇索引，则保存的是实际数据
    - 如果是非聚簇索引，则保存的是非聚簇索引的索引key

## 基本SQL用法
1. **创建**
    - ALTER 方式
        - 普通索引 `ALTER table ADD INDEX index_name(column1, column2);`
        - 唯一索引 ADD UNIQUE
        - 主键索引 ADD PRIMARY KEY
    - CREATE 方式
        - 普通方式 `CREATE INDEX index_name ON table_name (column_list)`
        - 唯一索引 `CREATE UNIQUE INDEX index_name ON table_name(column_list)`
1. **删除**
    - `DROP INDEX index_name ON talbe_name`
    - `ALTER TABLE table_name DROP INDEX index_name`
    - `ALTER TABLE table_name DROP PRIMARY KEY`      

1. **查看** 
    - `show index from tableName`
    - [Official Doc](https://dev.mysql.com/doc/refman/5.7/en/show-index.html)`详解命令的输出内容`

1. **强制使用索引**
    - `select * from test force index(id) where id = 1;`

# 索引的类型
`索引分类的概念，非MySQL真实索引类型`

> 覆盖索引
- InnoDB存储引擎支持覆盖索引（covering index，或称索引覆盖），即`仅从辅助索引中就可以得到查询的信息`，而不需要查询聚集索引中的记录。
- 使用覆盖索引的一个好处是辅助索引不包含整行记录的所有信息，故其大小要远小于聚集索引，因此可以减少大量的IO操作。

> 联合索引
- 两个或更多个列上的索引被称作联合索引，联合索引又叫复合索引

> 稠密索引
- 每个索引键值都对应有一个索引项

> 稀疏索引
- 相对于稠密索引，稀疏索引只为某些搜索码值建立索引记录；在搜索时，找到其最大的搜索码值小于或等于所查找记录的搜索码值的索引项，然后从该记录开始向后顺序查询直到找到为止。 

## 普通索引
是最基本的索引，只在单列上建立索引，无特殊限制

## 唯一索引
与前面的普通索引类似，不同的就是：索引列的值必须唯一，但允许有空值。如果是组合索引，则列值的组合必须唯一

## 主键索引
是一种特殊的唯一索引，一个表只能有一个主键，不允许有空值。
- 当创建表时没有显示定义主键时： 
    1. 首先判断表中是否有非空的整形唯一索引,如果有,则该列为主键(这时候可以使用 select _rowid from table 查询到主键列).
    2. 如果没有符合条件的则会自动创建一个6字节的主键(该主键是查不到的).

## 聚集索引
聚集索引(Clustered Index)

聚集索引：指索引项的排序方式和表中数据记录存储排序方式一致的索引 

而聚集索引（clustered index）就是按照每张表的主键构造一棵B+树，同时叶子节点中存放的即为`整张表的行记录数据`，也将聚集索引的叶子节点称为数据页。  
聚集索引的这个特性决定了索引组织表中数据也是索引的一部分。同B+树数据结构一样，每个数据页都通过一个双向链表来进行链接。

## 辅助索引/非聚集索引
辅助索引（Secondary Index，也称非聚集索引）

叶子节点并不包含行记录的全部数据。叶子节点除了包含键值以外，每个叶子节点中的索引行中还包含了一个书签（bookmark）。  
该书签用来告诉InnoDB存储引擎哪里可以找到与索引相对应的行数据。辅助索引的书签就是相应行数据的聚集索引键。  
辅助索引的存在并不影响数据在聚集索引中的组织，因此每张表上可以有多个辅助索引。  

当通过辅助索引来寻找数据时，InnoDB存储引擎会遍历辅助索引并通过叶级别的指针获得指向主键索引的主键，然后再通过主键索引来找到一个完整的行记录。

非聚集索引的使用场合为 查询所获数据量较少时 或者 某字段中的数据的唯一性比较高时， 非聚集索引必须是稠密索引

## Hash 索引

## 倒排索引

************************

# 需要使用索引的场景
1. 经常出现在 where 条件中的字段需添加索引。
2. join 关联，被驱动表需要对关联字段添加索引。
3. order by ，group by ，distinct的字段需要添加在索引的后面。

> 创建索引时避免有如下极端误解：
1. 宁滥勿缺。认为一个查询就需要建一个索引。
2. 宁缺勿滥。认为索引会消耗空间、严重拖慢更新和新增速度。
3. 抵制唯一索引。认为业务的唯一性一律需要在应用层通过“先查后插”方式解决。

************************

# SQL执行时不走索引的场景

- 如果MySQL分析器估计使用全表扫描要比使用索引快,则不使用索引(全部记录数量少于10 等等)
- 通过索引扫描的记录数超过20%-30%，可能会变成全表扫描。`和查询条件无关`

- 联合索引中，第一个索引列使用范围查询 > in 等等 (会用到部分索引)
- 联合索引中，最左前缀原则，查询条件不是最左索引列

- 条件查询时
    - 使用 or，
    - 使用 <>或！=
    - is null 或 is not null
    - 模糊查询 条件列`最左`是通配符`%`
    - 字符类型字段 查询条件没有使用 '', 例如 `where name = 1`,会导致索引失效，可能会正常查询，可能非预期结果
- HEAP表使用HASH索引时，使用范围检索或者ORDER BY
- 多表关联时，排序字段不属于驱动表，无法利用索引完成排序
- 两个独立索引，其中一个用于检索，一个用于排序(只能用到一个)
- JOIN查询时，关联列`数据类型/以及字符集/检验集`不一致也会导致索引不可用
- 对索引列进行运算

> 注意: 单列上存在 null 值, 索引仍能使用 

- [ ] 学习 null 和 索引的详细知识  

> 类型隐式转换
1. `where int_col='123'` 不会发生类型隐式转换，可使用索引
1. `where int_col='abc'` 'abc'被隐式转换为0，可使用索引
1. `where char_col=123` 发生类型隐式转换，不会使用索引
